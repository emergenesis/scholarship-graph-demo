// Generated by CoffeeScript 1.3.3
var $, defaultGraphSettings, get_or_edit_data, graphDemo, graph_data, graph_metadata, load_data,
  __hasProp = {}.hasOwnProperty;

$ = jQuery;

defaultGraphSettings = {
  vertex_min_radius: 5,
  vertex_max_radius: 20,
  height: 500,
  initial_data: "demo_initial_data.json"
};

get_or_edit_data = function($el, data, key) {
  var k;
  if (((function() {
    var _results;
    _results = [];
    for (k in data) {
      if (!__hasProp.call(data, k)) continue;
      _results.push(k);
    }
    return _results;
  })()).length === 0) {
    return $el.data(key);
  } else {
    data = $.extend({}, $el.data(key), data);
    return $el.data(key, data);
  }
};

graph_metadata = function($el, data) {
  return get_or_edit_data($el, data, "graphMetadata");
};

graph_data = function($el, data) {
  return get_or_edit_data($el, data, "graphData");
};

load_data = function($chart) {
  return function(newdata) {
    var circles, data, e, edgeIndex, edges, graph, graphSettings, initial, json, labels, max_weight, metadata, new_edges, new_vertices, v, vertices, vis, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    metadata = graph_metadata($chart);
    data = graph_data($chart);
    edgeIndex = [];
    max_weight = 1;
    vis = data.vis_element;
    graphSettings = metadata.graph_settings;
    initial = false;
    graph = metadata.graph;
    if (graph != null) {
      json = {
        edges: data.raw_edges.concat(newdata.edges),
        vertices: data.raw_vertices.concat(newdata.vertices)
      };
    } else {
      json = newdata;
      graph = d3.layout.force().charge(-500).linkDistance(graphSettings.vertex_max_radius * 5).gravity(.1).size([metadata.graph_width, metadata.graph_height]);
    }
    graph.on("tick", function(v) {
      json.vertices[0].x = metadata.graph_width / 2;
      json.vertices[0].y = metadata.graph_height / 2;
      vertices.attr("transform", function(v) {
        var r, x, y;
        r = parseInt(d3.select(this.parentNode).select("circle").attr("r"));
        x = Math.max(r, Math.min(metadata.graph_width - r, v.x));
        y = Math.max(r, Math.min(metadata.graph_height - r, v.y));
        v.x = x;
        v.y = y;
        return "translate(" + x + "," + y + ")";
      });
      edges.attr("x1", function(e) {
        return e.source.x;
      });
      edges.attr("x2", function(e) {
        return e.target.x;
      });
      edges.attr("y1", function(e) {
        return e.source.y;
      });
      return edges.attr("y2", function(e) {
        return e.target.y;
      });
    });
    graph.nodes(json.vertices).links(json.edges).start();
    _ref = json.edges;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      e = _ref[_i];
      edgeIndex["" + e.source.index + "," + e.target.index] = 1;
      edgeIndex["" + e.target.index + "," + e.source.index] = 1;
    }
    _ref1 = json.vertices;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      v = _ref1[_j];
      if (v.weight > max_weight) {
        max_weight = v.weight;
      }
    }
    new_edges = vis.selectAll("line.link").data(newdata.edges).enter().append("svg:line").attr("class", "edge").attr("x1", function(e) {
      return e.source.x;
    }).attr("x2", function(e) {
      return e.target.x;
    }).attr("y1", function(e) {
      return e.source.y;
    }).attr("y2", function(e) {
      return e.target.y;
    }).attr("title", function(e) {
      return e.label;
    });
    new_vertices = vis.selectAll("g.node").data(newdata.vertices).enter().append("svg:g").attr("class", "vertex").call(graph.drag);
    new_vertices.append("svg:circle").attr("class", "vcircle");
    new_vertices.append("svg:text").attr("class", "vlabel");
    vertices = vis.selectAll("g.vertex");
    edges = vis.selectAll("line.edge");
    circles = vis.selectAll("circle.vcircle");
    labels = vis.selectAll("text.vlabel");
    circles.attr("r", function(v) {
      return v.weight / max_weight * (graphSettings.vertex_max_radius - graphSettings.vertex_min_radius) + graphSettings.vertex_min_radius;
    }).attr("title", function(v) {
      return v.label;
    });
    labels.attr("dx", function(v, i) {
      var n;
      n = parseFloat(d3.select(this.parentNode).select("circle").attr("r"));
      return n + 5.0;
    }).attr("dy", 5).text(function(v) {
      return v.label;
    });
    _ref2 = vertices[0];
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      v = _ref2[_k];
      v.parentNode.appendChild(v);
    }
    graph_data($chart, {
      edge_index: edgeIndex,
      raw_vertices: json.vertices,
      raw_edges: json.edges,
      vertices: vertices,
      edges: edges,
      max_weight: max_weight
    });
    graph_metadata($chart, {
      settings: graphSettings,
      graph: graph
    });
    circles.on("mouseover", function(d, i) {
      data = graph_data($(this).parents(".graph"));
      vis.classed("hover", true);
      vertices.classed("active", function(v) {
        return edgeIndex[d.index + "," + v.index] || edgeIndex[v.index + "," + d.index] || d.index === v.index;
      });
      return edges.classed("active", function(e) {
        return e.source === d || e.target === d;
      });
    });
    return circles.on("mouseout", function() {
      vis.classed("hover", false);
      return edges.classed("active", false);
    });
  };
};

graphDemo = {
  init: function(options) {
    var graphSettings;
    graphSettings = $.extend({}, defaultGraphSettings, options);
    return this.each(function() {
      var $chart, metadata;
      $chart = $(this);
      metadata = graph_metadata($chart);
      if (!(metadata != null)) {
        console.log("Initializing on element", this);
        graph_metadata($chart, {
          graph_width: $chart.parent().width() - 2,
          graph_height: graphSettings.height,
          graph_settings: graphSettings
        });
        return $("a.initiate", $chart).click(function() {
          return $chart.graphDemo("start");
        });
      }
    });
  },
  start: function() {
    return this.each(function() {
      var $chart, metadata, vis;
      $chart = $(this);
      metadata = graph_metadata($chart);
      if (metadata.running) {
        $.error("The graph demo is already running!");
        return;
      } else {
        graph_metadata($chart, {
          running: true
        });
      }
      console.log("Running the plugin on element", this);
      $("a.initiate", $chart).remove();
      $chart.addClass("active");
      vis = d3.select(this).append("svg:svg").attr("width", metadata.graph_width).attr("height", metadata.graph_height);
      graph_data($chart, {
        vis_element: vis
      });
      return $chart.graphDemo("add", metadata.graph_settings.initial_data);
    });
  },
  toggleState: function(state) {
    return this.each(function() {
      var $chart;
      $chart = $(this);
      return $chart.toggleClass(state);
    });
  },
  stop: function() {
    return this.each(function() {
      var $chart;
      $chart = $(this);
      graph_metadata($chart, {
        running: false
      });
      $chart.empty();
      return $chart.removeClass("active linked highlighted");
    });
  },
  add: function(uri) {
    return this.each(function() {
      var $chart, metadata;
      $chart = $(this);
      metadata = graph_data($chart);
      console.log("Adding data from " + uri);
      return d3.json(uri, load_data($chart));
    });
  }
};

$.fn.graphDemo = function(method) {
  if (method in graphDemo) {
    return graphDemo[method].apply(this, Array.prototype.slice.call(arguments, 1));
  } else if (!(method != null) || typeof method === 'object') {
    return graphDemo.init.apply(this, arguments);
  } else {
    return $.error("Method " + method + " is undefined on jQuery.graphDemo.");
  }
};
